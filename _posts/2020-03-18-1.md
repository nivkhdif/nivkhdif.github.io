---
title: "안드로이드 플랫폼 구조"
date: 2020-3-18 00:00:01
categories:
---


## 플랫폼(Platform)

컴퓨터 시스템의 기본이 되는 특정 프로세서 모델과

  하나의 컴퓨터 시스템을 바탕으로 하는 운영체제







## 아키텍쳐(Architecture)

소프트웨어의 구성요소 사이의 관계, 시스템에 대한 구조의 집합







## 안드로이드 플랫폼 구조



![계층도](https://www.charlezz.com/wordpress/wp-content/uploads/2018/10/1262px-Android-System-Architecture.svg_-1024x831.png)







## Linux 커널

부팅시 부트로더를통해 먼저실행됨

스레딩, 하위수준 메모리관리,등에 관여하는계층



주요기능:



프로세스간통신(binder)



스레딩



init - 초기화,컨텍스트매니저,미디어서버,zygote실행



컨텍스트매니저 - 시스템서비스 관리



*시스템서비스 - 안드로이드 프레임워크의 중요 컴포넌트, 카메라, 오디오, 비디오 처리에서부터 각종 어플리케이션 제작에

			필요한 중요 API를 제공하는 역할을 수행(구현시 SystemService를 호출하여 구현)



미디어서버 - 오디오출력 , 카메라서비스담당



zygote - 로딩시간단축 ,  자바 기반 안드로이드 어플리케이션은 Zygote를 통해 포크된 프로세스 상에서 동작



시스템서버 - Zygote에서 최초로 포크되어 실행되는 안드로이드 어플리케이션 프로세스

		  Activity Manager Service와 Location Manager Service 같은 자바 시스템 서비스를 실행하는 역할





@여러 하드웨어들을 물리적으로 제어하는역할

@실제물리적,전자적인 명령을 내리는듯함 , 이해하기 어려워보임..

@시스템구동,하드웨어를 사용한 서비스제공에 필수적인 명령들







## HAL(하드웨어 추상화 계층)

하드웨어의 기본적 인터페이스를 정의하고

같은명령을 하드웨어가 달라질때마다 만들지않고,

차이나는 부분만을 수정해서 변화에 유연하며 일관성있게 대응하기위한층

@특정하드웨어가 공통으로 꼭 필요한특징을 담고있음.

@(그 하드웨어를 특정 하드웨어로 정의하게 해주는 기능들)

@변화에대한 완충작용







## 네이티브 C/C++ 라이브러리

ART 및 HAL 등의 많은 핵심 Android 시스템 구성 요소와 서비스

 C 및 C++로 작성된

 네이티브 라이브러리를 필요로 하는 네이티브 코드를 기반으로 빌드되었습니다.

 Android 플랫폼은 Java 프레임워크 API를 제공하여

 이러한 일부 네이티브 라이브러리의 기능을 앱에 노출합니다.

 예를 들어, Android 프레임워크의 Java OpenGL API를 통해

 OpenGL ES에 액세스하여 앱에서 2D 및 3D 그래픽을 그리고

 조작할 수 있는 지원 기능을 추가할 수 있습니다.



@커널명령의 집합,반복으로 이루어진 더큰단위의 작업?

@이해하기힘든 낮은수준의명령을 쌓아서만든 더크고 논리적인 수행단위의 느낌











## Android 런타임



 ART의 주요 기능



AOT(Ahead-Of-Time) 및 JIT(Just-In-Time) 컴파일

최적화된 가비지 컬렉션(GC)

Android 9(API 레벨 28) 이상에서 앱 패키지의 DEX(Dalvik Executable) 형식 파일이 더욱 간소한 기계 코드로 변환됨

전용 샘플링 프로파일러, 상세 진단 예외 및 크래시 보고, watchpoint를 설정하여 특정 필드를 모니터링할 수 있는 기능을 비롯한 향상된 디버깅 지원 기능



@네이티브 라이브러리중에 좀더 중요한 역할을하는 명령이담긴 라이브러리들로보임

@프레임워크의 Java코드를 native로 번역해주는 라이브러리,

@시스템관리, 디버깅관련 명령들도 여기있는걸로보임.





//자바 가상머신

다른언어들은 플랫폼에맞는 형태로 코딩되지만,

자바는 플랫폼 상관없이 자신의 바이트코드로 존재,

>>자바코드는 가상머신을 올린후 실행해야함



1.달빅(jit컴파일러)  jit = just in time

실시간으로 수행될명령을 번역하는 방식사용

	장점:저장공간을 덜사용함

	단점1: JIT컴파일러가 돌아가는 동안에 하드웨어의 부하가 크게 발생,배터리소모큼

	단점2:애플리케이션 실행시, 실행부분 전체를 RAM에 상주시켜야함





2.art(aot컴파일러)    aot  = Ahead of time

어플설치시 자바코드를 통채로 번역해서 저장해놓고 명령을수행

	장점::네이티브언어급 속도

	단점::애플리케이션 설치 공간이 달빅 VM에 비해서 약 1.5 ~ 2배 정도 더 필요함



	특이점::

	NAVTIVE MACHINE CODE를 담고 있으며,

	가상머신을 거치지 않고 실행되어 네이티브로 볼 수 있지만,

	달빅VM에서 실행하는 것과 논리적으로 동일한 결과물을 제공하기 위해

	OAT에 저장된 NATIVE MACHINE CODE 안에는 가상머신 상태를

	흉내낸 부가적인 코드도 있습니다.

	즉 ART는 앱이 가상머신 위에서 사용되지 않지만,

	그렇다고 가상머신으로부터 자유롭지도 않은 형태입니다.



3.혼합

안드로이드 7.0 부터는 앱 설치시간단축을 위해 최초설치시에는 JIT를 사용하고

충전중이거나 기기를 사용하지 않는 대기모드 상태일때

부분컴파일작업을 실시하여 점진적으로 AOT방식으로 바꾸어 나가는방식 사용

>>달빅VM과 ART의 장점을 합치고 단점을 해결하려는 시도











## 안드로이드 프레임워크(ANDROID FRAMEWORK)  (Java)



Android OS의 전체 기능 세트는 Java 언어로 작성된 API를 통해 액세스할 수 있습니다.

이러한 API는 핵심 모듈식 시스템 구성 요소 및 서비스 재활용을 단순화하여

Android 앱을 제작하는 데 필요한 빌딩 블록을 구성하며, 이러한 빌딩 블록에는 다음이 포함됩니다.



    기능이 풍부하며 확장 가능한 뷰 시스템 - 목록, 그리드, 텍스트 상자, 버튼 및 삽입 가능한 웹브라우저를 포함하여 앱의 UI를 빌드하는 데 사용 가능

    Resource Manager - 현지화된 문자열, 그래픽 및 레이아웃 파일과 같은 코드가 아닌 리소스에 대한 액세스 제공

    Notification Manager - 모든 앱이 상태 표시줄에 사용자 지정 알림을 표시할 수 있도록 지원

    Activity Manager - 앱의 수명 주기를 관리하고 공통 탐색 백 스택 제공

    콘텐츠 제공자 - 앱이 주소록 앱과 같은 다른 앱의 데이터에 액세스하거나 자신의 데이터를 공유할 수 있도록 지원

	개발자는 Android 시스템 앱이 사용하는 것과 동일한 프레임워크 API에 대한 전체 액세스 권한을 가집니다.





@커널명령,네이티브라이브러리명령, 등 낮은수준명령들의 모음,반복으로 만든 좀더큰 단위의명령?

@인간이 자연스럽게 이해할만큼 큰단위의 명령들같은 느낌

@인간언어의 기본적인 동사들? 같음



@걷다     //framework

@발을들다 - 발을옮기다 - 발을내려놓다 // native libarary

@다리의 움직임을위한,뇌의명령,근육,피부,전자,호르몬,등 낮은레벨의작업   // kernel??









## 시스템 앱

@하위레벨에서 기본적으로 제공해주는 명령들을 쌓아서

@사용자가필요한 작업단위를 만드는 계층으로보임

@ex)건축하다 라는작업은

@지을곳을 미리준비해놓고

@벽돌을  들고,옮기고,내려놓는 작업의 반복으로 만들어짐

@들고 옮기고,내려놓는 기본적 동사는 framework layer에 해당한다고볼수있다?



@명령을따라 kernel레벨까지 내려가야 실제물리적변화가 일어날것















































