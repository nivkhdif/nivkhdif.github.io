---
title: "윈도우 매니저"
date: 2020-5-13 00:00:01
categories:
---




surfaceflinger 시스템프로세스, 프로세스의 창을하나로
프레임버퍼에 내용을 작성해서 하나의 그림을그림

surface : 각 디스플에이 인터페이스 창
새창추가 = 새 surface할당


## WindowManager         :: 애플리케이션과 WindowManagerSerivce  간의 소통interface

ViewManager를 상속하여 구현됨

```
public interface ViewManager{
    / / Add View
    public void addView(View view, ViewGroup.LayoutParams params);
    / / Update View
    public void updateViewLayout(View view, ViewGroup.LayoutParams params);
    / / Delete View
    public void removeView(View view);
}Copy code
```

1.Add 
2.Update
3.Delete 
ㅡ3개의 method를 가짐



## WindowManager 의 구현클래스 = WindowManagerImpl

## WindowManagerImpl의 기능구현클래스 = WindowManagerGlobal

```
public final class WindowManagerGlobal {
 
     public void addView(View view, ViewGroup.LayoutParams params,
                Display display, Window parentWindow) {
            / / Check the validity of the parameters
            ...
 
            //ViewRootImpl encapsulates the interaction between View and WindowManager
            ViewRootImpl root;
            View panelParentView = null;
 
            synchronized (mLock) {
                // Start watching for system property changes.
                if (mSystemPropertyUpdater == null) {
                    mSystemPropertyUpdater = new Runnable() {
                        @Override public void run() {
                            synchronized (mLock) {
                                for (int i = mRoots.size() - 1; i >= 0; --i) {
                                    mRoots.get(i).loadSystemProperties();
                                }
                            }
                        }
                    };
                    SystemProperties.addChangeCallback(mSystemPropertyUpdater);
                }
 
                int index = findViewLocked(view, false);
                if (index >= 0) {
                    if (mDyingViews.contains(view)) {
                        // Don't wait for MSG_DIE to make it's way through root's queue.
                        mRoots.get(index).doDie();
                    } else {
                        throw new IllegalStateException("View " + view
                                + " has already been added to the window manager.");
                    }
                    // The previous removeView() had not completed executing. Now it has.
                }
 
                // If this is a panel window, then find the window it is being
                // attached to for future reference.
                if (wparams.type >= WindowManager.LayoutParams.FIRST_SUB_WINDOW &&
                        wparams.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                    final int count = mViews.size();
                    for (int i = 0; i < count; i++) {
                        if (mRoots.get(i).mWindow.asBinder() == wparams.token) {
                            panelParentView = mViews.get(i);
                        }
                    }
                }
 
                / / Build ViewRootImpl through the context
                root = new ViewRootImpl(view.getContext(), display);
 
                view.setLayoutParams(wparams);
 
                //mViews stores all View objects corresponding to Window
                mViews.add(view);
                //mRoots stores all ViewRootImpl objects corresponding to Window
                mRoots.add(root);
                //mParams stores all WindowManager.LayoutParams objects corresponding to Window
                mParams.add(wparams);
            }
 
            // do this last because it fires off messages to start doing things
            try {
                / / Call the ViewRootImpl.setView () method to complete the addition of Window and update the interface
                root.setView(view, wparams, panelParentView);
            } catch (RuntimeException e) {
                // BadTokenException or InvalidDisplayException, clean up.
                synchronized (mLock) {
                    final int index = findViewLocked(view, false);
                    if (index >= 0) {
                        removeViewLocked(index, true);
                    }
                }
                throw e;
            }
        }
 
}Copy code
```


중요멤버
mViews    view 객체 저장
mRoots   ViewRootImpl  객체 저장 
mParams WindowManager.LayoutParams 객체 저장

ViewRootImpl 클래스::
View와  WindowManager간 상호작용을 캡슐화하는 래퍼클래스



 ViewRootImpl.setView() 호출
:::창의 추가와 업데이트완료




![d](url)  

















## 카메라앱의 바인더호출



Camera 서비스의 내부 동작

Camera.cpp는 Camera::getCameraService()를 통해서 ICameraService 를 호출한다.

실제는 BpCameraService가 호출될 때 이루어진다. BpCameraService는 binder를 통해서 두 프로세스 사이의 BnCameraService 통신채널을 생성한다. BpCamera Service의 connect()함수에서는 다음과 같이 BnCamera Service를 연결시키는 부분이 있다.



remote()->transact(BnCameraService::CONNECT, data, &reply);





Camera server로의 서비스 요청

카메라 서비스로의 접속은 서비스 매니저로부터 Camera Service를 담당하는 binder class인 ICamera Service를 get함으로써 이루어진다. 물론, 그 전에 ICameraClient 형의 Camera class를 생성함으로써 Camera client로부터 Camera server(카메라 서비스)로의 Binder 연결이 이루어진다.



CONNECT command를 통해서 카메라 서비스로 접속을 하게 되면 카메라 서비스 쪽에서는 server에서 client로 접속되는 ICamera 형의 client class를 생성해서 Camera client 쪽으로 할당해 준다. ICameraService를 이용한 Binder interface는 CONNECT command외에 다른 command는 존재하지 않는다. 이 Class는 오직 connect를 받아서 새로운 Binder를 생성(server에서 client로의 data 통로를 여는)하기만 할 뿐이다.



위의 메커니즘 설명은 이러한 부분에 대한 기술적인 설명을 하는 부분이 된다. IPC인 Binder 부분은 실제 호출되는 부분과 실행되는 부분이 감추어져 있기 때문에 코드에 대한 추적이 어렵다.

즉, ICameraService.cpp의 BpCameraService의 connect()를 통해, CameraService.cpp의 Camera



Service::onTransact() 로 아래의 내용을



status_t err = BnCameraService::onTransact(code, data, reply, flags);



호출함으로써 두 개의 프로세스간 BnCameraService()통신채널을 구성하게 된다. 실제 BpCameraService의 구현은 CameraServicce에서 이루어진다고 보면 된다. Camera.cpp는 다른 프로세스로 동작 하지만, 그 인터페이스는 ICameraService의 connect()를 호출함으로써 CameraService의 ICamera class인 CameraService:: Client를 획득할 수 있게 된다. Camera에 관련된 함수들은 CameraService:: Client 가 생성되면서 실제로 구현된다.





출처 : 테크월드(http://www.epnc.co.kr)



